<html><head>
<title>Taylor's Ode Solver: An Example and Test</title>
<meta name="description" id="description" content="Taylor's Ode Solver: An Example and Test">
<meta name="keywords" id="keywords" content=" Ode Taylor example test ">
<style type='text/css'>
body { color : black }
body { background-color : white }
A:link { color : blue }
A:visited { color : purple }
A:active { color : purple }
</style>
<script type='text/javascript' language='JavaScript' src='_ode_taylor.cpp_htm.js'>
</script>
</head>
<body>
<table><tr>
<td>
<a href="http://www.coin-or.org/CppAD/" target="_top"><img border="0" src="_image.gif"></a>
</td>
<td>
<select onchange='choose_across0(this)'>
<option>Index-&gt;</option>
<option>contents</option>
<option>reference</option>
<option>index</option>
<option>search</option>
<option>external</option>
</select>
</td>
<td>
<select onchange='choose_up0(this)'>
<option>Up-&gt;</option>
<option>CppAD</option>
<option>Example</option>
<option>General</option>
<option>ode_taylor.cpp</option>
</select>
</td>
<td><a href="odestiff.cpp.htm" target="_top">Prev</a>
</td><td><a href="ode_taylor_adolc.cpp.htm" target="_top">Next</a>
</td><td>
<select onchange='choose_down3(this)'>
<option>CppAD-&gt;</option>
<option>Install</option>
<option>Introduction</option>
<option>AD</option>
<option>ADFun</option>
<option>library</option>
<option>preprocessor</option>
<option>Example</option>
<option>Appendix</option>
</select>
</td>
<td>
<select onchange='choose_down2(this)'>
<option>Example-&gt;</option>
<option>General</option>
<option>ExampleUtility</option>
<option>ListAllExamples</option>
<option>test_vector</option>
</select>
</td>
<td>
<select onchange='choose_down1(this)'>
<option>General-&gt;</option>
<option>Interface2C.cpp</option>
<option>JacMinorDet.cpp</option>
<option>JacLuDet.cpp</option>
<option>HesMinorDet.cpp</option>
<option>HesLuDet.cpp</option>
<option>OdeStiff.cpp</option>
<option>ode_taylor.cpp</option>
<option>ode_taylor_adolc.cpp</option>
<option>StackMachine.cpp</option>
<option>mul_level</option>
</select>
</td>
<td>ode_taylor.cpp</td>
<td>
<select onchange='choose_current0(this)'>
<option>Headings-&gt;</option>
<option>Purpose</option>
<option>ODE</option>
<option>ODE Solution</option>
<option>Derivative of ODE Solution</option>
<option>Taylor's Method Using AD</option>
</select>
</td>
</tr></table><br>



<center><b><big><big>Taylor's Ode Solver: An Example and Test</big></big></b></center>
<br>
<b><big><a name="Purpose" id="Purpose">Purpose</a></big></b>
<br>
This is a realistic example using 
two levels of taping (see <a href="mul_level.htm" target="_top"><span style='white-space: nowrap'>mul_level</span></a>
).
The first level of taping uses <code><font color="blue">AD&lt;double&gt;</font></code> to tape the solution of an 
ordinary differential equation.
This solution is then differentiated with respect to a parameter vector.
The second level of taping uses <code><font color="blue">AD&lt; AD&lt;double&gt; &gt;</font></code>
to take derivatives during the solution of the differential equation.
These derivatives are used in the application
of Taylor's method to the solution of the ODE.
The example <a href="ode_taylor_adolc.cpp.htm" target="_top"><span style='white-space: nowrap'>ode_taylor_adolc.cpp</span></a>
 computes the same values using
Adolc's type <code><font color="blue">adouble</font></code> and CppAD's type <code><font color="blue">AD&lt;adouble&gt;</font></code>.

<br>
<br>
<b><big><a name="ODE" id="ODE">ODE</a></big></b>
<br>
For this example the ODE's are defined by the function
<code>
<span style='white-space: nowrap'>&nbsp;h&nbsp;:&nbsp;\R^n&nbsp;\times&nbsp;\R^n&nbsp;\rightarrow&nbsp;\R^n</span></code>
 where
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h[&nbsp;x,&nbsp;y(t,&nbsp;x)&nbsp;]&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\left(&nbsp;\begin{array}{c}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_1&nbsp;y_0&nbsp;(t,&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\vdots&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_{n-1}&nbsp;y_{n-2}&nbsp;(t,&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\end{array}&nbsp;\right)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\left(&nbsp;\begin{array}{c}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\partial_t&nbsp;y_0&nbsp;(t&nbsp;,&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\partial_t&nbsp;y_1&nbsp;(t&nbsp;,&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\vdots&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\partial_t&nbsp;y_{n-1}&nbsp;(t&nbsp;,&nbsp;x)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\end{array}&nbsp;\right)<br>
\]&nbsp;</span></code>

and the initial condition <code>
<span style='white-space: nowrap'>&nbsp;y(0,&nbsp;x)&nbsp;=&nbsp;0</span></code>
.
The value of <code>
<span style='white-space: nowrap'>&nbsp;x</span></code>
 is fixed during the solution of the ODE
and the function <code>
<span style='white-space: nowrap'>&nbsp;g&nbsp;:&nbsp;\R^n&nbsp;\rightarrow&nbsp;\R^n</span></code>
 is used to
define the ODE where
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g(y)&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\left(&nbsp;\begin{array}{c}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_1&nbsp;y_0&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\vdots&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_{n-1}&nbsp;y_{n-2}&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\end{array}&nbsp;\right)<br>
\]&nbsp;</span></code>
	

<br>
<br>
<b><big><a name="ODE Solution" id="ODE Solution">ODE Solution</a></big></b>
<br>
The solution for this example can be calculated by 
starting with the first row and then using the solution
for the first row to solve the second and so on.
Doing this we obtain
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y(t,&nbsp;x&nbsp;)&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\left(&nbsp;\begin{array}{c}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_0&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_1&nbsp;x_0&nbsp;t^2&nbsp;/&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\vdots&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_{n-1}&nbsp;x_{n-2}&nbsp;\ldots&nbsp;x_0&nbsp;t^n&nbsp;/&nbsp;n&nbsp;!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\end{array}&nbsp;\right)<br>
\]&nbsp;</span></code>


<br>
<br>
<b><big><a name="Derivative of ODE Solution" id="Derivative of ODE Solution">Derivative of ODE Solution</a></big></b>
<br>
Differentiating the solution above,
with respect to the parameter vector <code>
<span style='white-space: nowrap'>&nbsp;x</span></code>
,
we notice that
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
\partial_x&nbsp;y(t,&nbsp;x&nbsp;)&nbsp;=<br>
\left(&nbsp;\begin{array}{cccc}<br>
y_0&nbsp;(t,x)&nbsp;/&nbsp;x_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;\cdots&nbsp;&amp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
y_1&nbsp;(t,x)&nbsp;/&nbsp;x_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;y_1&nbsp;(t,x)&nbsp;/&nbsp;x_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;\vdots&nbsp;\\<br>
\vdots&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;\vdots&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;\ddots&nbsp;&amp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
y_{n-1}&nbsp;(t,x)&nbsp;/&nbsp;x_0&nbsp;&nbsp;&amp;&nbsp;y_{n-1}&nbsp;(t,x)&nbsp;/&nbsp;x_1&nbsp;&amp;&nbsp;\cdots&nbsp;&amp;&nbsp;y_{n-1}&nbsp;(t,x)&nbsp;/&nbsp;x_{n-1}<br>
\end{array}&nbsp;\right)<br>
\]&nbsp;</span></code>


<br>
<br>
<b><big><a name="Taylor's Method Using AD" id="Taylor's Method Using AD">Taylor's Method Using AD</a></big></b>
<br>
An <i>m</i>-th order Taylor method for 
approximating the solution of an
ordinary differential equations is 
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y(t&nbsp;+&nbsp;\Delta&nbsp;t&nbsp;,&nbsp;x)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\approx&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\sum_{k=0}^p&nbsp;\partial_t^k&nbsp;y(t&nbsp;,&nbsp;x&nbsp;)&nbsp;\frac{&nbsp;\Delta&nbsp;t^k&nbsp;}{&nbsp;k&nbsp;!&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y^{(0)}&nbsp;(t&nbsp;,&nbsp;x&nbsp;)&nbsp;+&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y^{(1)}&nbsp;(t&nbsp;,&nbsp;x&nbsp;)&nbsp;\Delta&nbsp;t&nbsp;+&nbsp;\cdots&nbsp;+&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y^{(p)}&nbsp;(t&nbsp;,&nbsp;x&nbsp;)&nbsp;\Delta&nbsp;t^p<br>
\]&nbsp;</span></code>

where the Taylor coefficients <code>
<span style='white-space: nowrap'>&nbsp;y^{(k)}&nbsp;(t,&nbsp;x)</span></code>
 are defined by
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y^{(k)}&nbsp;(t,&nbsp;x)&nbsp;=&nbsp;\partial_t^k&nbsp;y(t&nbsp;,&nbsp;x&nbsp;)&nbsp;/&nbsp;k&nbsp;!<br>
\]&nbsp;</span></code>

We define the function <code>
<span style='white-space: nowrap'>&nbsp;z(t,&nbsp;x)</span></code>
 by the equation
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;(&nbsp;t&nbsp;,&nbsp;x&nbsp;)&nbsp;=&nbsp;g[&nbsp;y&nbsp;(&nbsp;t&nbsp;,&nbsp;x&nbsp;)&nbsp;]&nbsp;=&nbsp;h&nbsp;[&nbsp;x&nbsp;,&nbsp;y(&nbsp;t&nbsp;,&nbsp;x&nbsp;)&nbsp;]<br>
\]&nbsp;</span></code>

It follows that 
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
\begin{array}{rcl}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\partial_t&nbsp;y(t,&nbsp;x)&nbsp;&amp;&nbsp;=&nbsp;&amp;&nbsp;z&nbsp;(t&nbsp;,&nbsp;x)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\partial_t^{k+1}&nbsp;y(t&nbsp;,&nbsp;x)&nbsp;&amp;&nbsp;=&nbsp;&amp;&nbsp;\partial_t^k&nbsp;z&nbsp;(t&nbsp;,&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y^{(k+1)}&nbsp;(&nbsp;t&nbsp;,&nbsp;x)&nbsp;&amp;&nbsp;=&nbsp;&amp;&nbsp;z^{(k)}&nbsp;(t,&nbsp;x)&nbsp;/&nbsp;(k+1)&nbsp;<br>
\end{array}<br>
\]&nbsp;</span></code>

where <code>
<span style='white-space: nowrap'>&nbsp;&nbsp;z^{(k)}&nbsp;(t,&nbsp;x)</span></code>
 is the 
<i>k</i>-th order Taylor coefficient
for <code>
<span style='white-space: nowrap'>&nbsp;z(t,&nbsp;x)</span></code>
.
In the example below, the Taylor coefficients
<code>
<span style='white-space: nowrap'>&nbsp;\[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y^{(0)}&nbsp;(t&nbsp;,&nbsp;x)&nbsp;,&nbsp;\ldots&nbsp;,&nbsp;y^{(k)}&nbsp;(&nbsp;t&nbsp;,&nbsp;x&nbsp;)<br>
\]&nbsp;</span></code>

are used to calculate the Taylor coefficient <code>
<span style='white-space: nowrap'>&nbsp;z^{(k)}&nbsp;(&nbsp;t&nbsp;,&nbsp;x&nbsp;)</span></code>

which in turn gives the value for <code>
<span style='white-space: nowrap'>&nbsp;&nbsp;y^{(k+1)}&nbsp;y&nbsp;(&nbsp;t&nbsp;,&nbsp;x)</span></code>
.

<code><font color="blue">
<pre style='display:inline'> 

# include &lt;cppad/cppad.hpp&gt;

// =========================================================================
// define types for each level
namespace { // BEGIN empty namespace
typedef CppAD::AD&lt;double&gt;     ADdouble;
typedef CppAD::AD&lt; ADdouble &gt; ADDdouble;

// -------------------------------------------------------------------------
// class definition for C++ function object that defines ODE
class Ode {
private:
	// copy of a that is set by constructor and used by g(y)
	CPPAD_TEST_VECTOR&lt; ADdouble &gt; x_; 
public:
	// constructor
	Ode( CPPAD_TEST_VECTOR&lt; ADdouble &gt; x) : x_(x)
	{ }
	// the function g(y) is evaluated with two levels of taping
	CPPAD_TEST_VECTOR&lt; ADDdouble &gt; operator()
	( const CPPAD_TEST_VECTOR&lt; ADDdouble &gt; &amp;y) const
	{	size_t n = y.size();
		CPPAD_TEST_VECTOR&lt; ADDdouble &gt; g(n);
		size_t i;
		g[0] = x_[0];
		for(i = 1; i &lt; n; i++)
			g[i] = x_[i] * y[i-1];

		return g;
	}
};

// -------------------------------------------------------------------------
// Routine that uses Taylor's method to solve ordinary differential equaitons
// and allows for algorithmic differentiation of the solution. 
CPPAD_TEST_VECTOR &lt; ADdouble &gt; taylor_ode(
	Ode                     G       ,  // function that defines the ODE
	size_t                  order   ,  // order of Taylor's method used
	size_t                  nstep   ,  // number of steps to take
	ADdouble                &amp;dt     ,  // Delta t for each step
	CPPAD_TEST_VECTOR&lt; ADdouble &gt; &amp;y_ini  )  // y(t) at the initial time
{
	// some temporary indices
	size_t i, k, ell;

	// number of variables in the ODE
	size_t n = y_ini.size();

	// copies of x and g(y) with two levels of taping
	CPPAD_TEST_VECTOR&lt; ADDdouble &gt;   Y(n), Z(n);

	// y, y^{(k)} , z^{(k)}, and y^{(k+1)}
	CPPAD_TEST_VECTOR&lt; ADdouble &gt;  y(n), y_k(n), z_k(n), y_kp(n);
	
	// initialize x
	for(i = 0; i &lt; n; i++)
		y[i] = y_ini[i];

	// loop with respect to each step of Taylors method
	for(ell = 0; ell &lt; nstep; ell++)
	{	// prepare to compute derivatives of in ADdouble
		for(i = 0; i &lt; n; i++)
			Y[i] = y[i];
		CppAD::Independent(Y);

		// evaluate ODE in ADDdouble
		Z = G(Y);

		// define differentiable version of g: X -&gt; Y
		// that computes its derivatives in ADdouble
		CppAD::ADFun&lt;ADdouble&gt; g(Y, Z);

		// Use Taylor's method to take a step
		y_k            = y;     // initialize y^{(k)}
		ADdouble dt_kp = dt;    // initialize dt^(k+1)
		for(k = 0; k &lt;= order; k++)
		{	// evaluate k-th order Taylor coefficient of y
			z_k = g.Forward(k, y_k);
 
			for(i = 0; i &lt; n; i++)
			{	// convert to (k+1)-Taylor coefficient for x
				y_kp[i] = z_k[i] / ADdouble(k + 1);

				// add term for to this Taylor coefficient
				// to solution for y(t, x)
				y[i]    += y_kp[i] * dt_kp;
			}
			// next power of t
			dt_kp *= dt;
			// next Taylor coefficient
			y_k   = y_kp;
		}
	}
	return y;
}
} // END empty namespace
// ==========================================================================
// Routine that tests alogirhtmic differentiation of solutions computed
// by the routine taylor_ode.
bool ode_taylor(void)
{	// initialize the return value as true	
	bool ok = true;

	// number of components in differential equation
	size_t n = 4;

	// some temporary indices
	size_t i, j;

	// parameter vector in both double and ADdouble
	CPPAD_TEST_VECTOR&lt;double&gt;   x(n);
	CPPAD_TEST_VECTOR&lt;ADdouble&gt; X(n);
	for(i = 0; i &lt; n; i++)
		X[i] = x[i] = double(i + 1);

	// declare the parameters as the independent variable
	CppAD::Independent(X);

	// arguments to taylor_ode 
	Ode G(X);                // function that defines the ODE
	size_t   order = n;      // order of Taylor's method used
	size_t   nstep = 2;      // number of steps to take
	ADdouble DT    = 1.;     // Delta t for each step
	// value of y(t, x) at the initial time
	CPPAD_TEST_VECTOR&lt; ADdouble &gt; Y_INI(n);
	for(i = 0; i &lt; n; i++)
		Y_INI[i] = 0.;

	// integrate the differential equation
	CPPAD_TEST_VECTOR&lt; ADdouble &gt; Y_FINAL(n);
 	Y_FINAL = taylor_ode(G, order, nstep, DT, Y_INI);

	// define differentiable fucntion object f : A -&gt; Y_FINAL
	// that computes its derivatives in double
	CppAD::ADFun&lt;double&gt; f(X, Y_FINAL);

	// check function values
	double check = 1.;
	double t     = nstep * Value(DT);
	for(i = 0; i &lt; n; i++)
	{	check *= x[i] * t / double(i + 1);
		ok &amp;= CppAD::NearEqual(Value(Y_FINAL[i]), check, 1e-10, 1e-10);
	}

	// evaluate the Jacobian of h at a
	CPPAD_TEST_VECTOR&lt;double&gt; jac = f.Jacobian(x);

	// check Jacobian 
	for(i = 0; i &lt; n; i++)
	{	for(j = 0; j &lt; n; j++)
		{	double jac_ij = jac[i * n + j]; 
			if( i &lt; j )
				check = 0.;
			else	check = Value( Y_FINAL[i] ) / x[j];
			ok &amp;= CppAD::NearEqual(jac_ij, check, 1e-10, 1e-10);
		}
	}
	return ok;
}

</pre>

</font></code>


<hr>Input File: example/ode_taylor.cpp

</body>
</html>
